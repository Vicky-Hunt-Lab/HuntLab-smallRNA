{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hunt Lab Small RNA Pipeline Documentation","text":"<p>This documentation is for version 2 of the pipeline, select 1.1.0 from the version dropdown for the version 1 documentation.</p> <p>This is a pipeline developed in Vicky Hunt's Lab at the University of Bath, UK to analyse small RNA data in a quick and consistent way between projects. It is deliberately designed to be highly configurable so it can be easily applied to a wide range of scenarios, though most of our work is on nematode and nematomorph worms. </p>"},{"location":"#background","title":"Background","text":"<p>Most of the original methodology was devised by Mona Suleiman, Dominika Lastik and Vicky Hunt for the papers below. This was then developed into a usable pipeline by Kieran Reynolds in 2022 and updated to version 2 in 2025. </p> <p>Suleiman, M., Kounosu, A., Murcott, B. et al. piRNA-like small RNAs target transposable elements in a Clade IV parasitic nematode. Sci Rep 12, 10156 (2022). https://doi.org/10.1038/s41598-022-14247-1</p> <p>Lastik, D., Kounosu, A., Dayi, M. et al. Small non-coding RNAs have predicted roles in reproductive biology and transposable element regulation in the parasitic worm Strongyloides venezuelensis. Sci Rep 15, 20608 (2025). https://doi.org/10.1038/s41598-025-01968-2</p>"},{"location":"#citation","title":"Citation","text":"<p>This pipeline is mainly a combination of existing tools so, doesn't have a paper attached to it but can be referenced with the repository URL and version number. For example:</p> <p>This analysis was performed using HuntLab-smallRNA v2.0.0 (https://github.com/Vicky-Hunt-Lab/HuntLab-smallRNA).</p> <p>For the internal steps please cite the papers of the tools used:</p> <p>Trim:</p> <p>Martin, Marcel. (2011). CUTADAPT removes adapter sequences from high-throughput sequencing reads. EMBnet.journal. 17. 10.14806/ej.17.1.200.</p> <p>Sort:</p> <p>Langmead, B., Salzberg, S. Fast gapped-read alignment with Bowtie 2. Nat Methods 9, 357-359 (2012). https://doi.org/10.1038/nmeth.1923 </p> <p>Unitas:</p> <p>Gebert, D., Hewel, C. &amp; Rosenkranz, D. unitas: the universal tool for annotation of small RNAs. BMC Genomics 18, 644 (2017). https://doi.org/10.1186/s12864-017-4031-9</p> <p>Targetid:</p> <p>Langmead, B., Salzberg, S. Fast gapped-read alignment with Bowtie 2. Nat Methods 9, 357-359 (2012). https://doi.org/10.1038/nmeth.1923</p> <p>Enrich:</p> <p>Carlos P Cantalapiedra, Ana Hern\u00e1ndez-Plaza, Ivica Letunic, Peer Bork, Jaime Huerta-Cepas, eggNOG-mapper v2: Functional Annotation, Orthology Assignments, and Domain Prediction at the Metagenomic Scale, Molecular Biology and Evolution, Volume 38, Issue 12, December 2021, Pages 5825-5829, https://doi.org/10.1093/molbev/msab293</p>"},{"location":"installation/","title":"Installation","text":"<p>There are currently three different ways to install the pipeline, to allow for flexibility. The apptainer method is recommended as it is the quickest and most reliable, but the other two work if that is not possible.</p>"},{"location":"installation/#installing-using-apptainer-or-docker","title":"Installing using Apptainer or Docker","text":"<p>A containerised version of the pipeline is provided to allow for easy installation. Apptainer is recommended, as it allows for running with relative paths, but it will run in Docker as well. If you do not have these installed, see their websites for installation instructions:</p> <ul> <li>Apptainer:  https://apptainer.org/docs/admin/main/installation.html </li> <li>Docker: https://docs.docker.com/</li> </ul>"},{"location":"installation/#installing-with-apptainer","title":"Installing with Apptainer","text":"<p>Create a SIF file with the code by running the following:</p> <pre><code>$ apptainer pull hlsmallrna.sif docker://kieranr51/huntlab-smallrna\n</code></pre> <p>To test it works try displaying the help message with the following command:</p> <pre><code>$ apptainer run hlsmallrna.sif hlsmallrna --help\n</code></pre> <p>If this displays the help message, you are good to go. All subsequent commands can be run with:</p> <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif [COMMAND]\n</code></pre> <p>Binding Directories in Apptainer</p> <p>To allow access to your files to the pipeline in apptainer you will need to bind the directories for you input and output. The above command binds your home directory, but you may need to change this if your files are outside of that directory. See https://apptainer.org/docs/user/main/bind_paths_and_mounts.html for more information.</p>"},{"location":"installation/#installing-with-docker","title":"Installing with Docker","text":"<p>First pull the container with:</p> <pre><code>$ docker pull kieranr51/huntlab-smallrna\n</code></pre> <p>To test it works try displaying the help message with the following command:</p> <pre><code>$ docker run kieranr51/huntlab-smallrna hlsmallrna --help\n</code></pre> <p>If this displays the help message, you are good to go. All subsequent commands can be run with:</p> <pre><code>$ docker run -v $HOME:$HOME kieranr51/huntlab-smallrna [COMMAND]\n</code></pre> <p>Paths and Mounting Directories in Docker</p> <p>To allow access to your files to the pipeline in apptainer you will need to mount the directories for you input and output. The above command mounts your home directory, but you may need to change this if your files are outside of that directory. See https://docs.docker.com/engine/storage/bind-mounts/ for more information.</p> <p>Docker hides the current path you are working in from the program as well, so you will have to specify the absolute path to your input and output files to get it to work. E.g. if your config file is in /home/user/smallrna/config.yml you would have to run:</p> <pre><code>$ docker run -v $HOME:$HOME kieranr51/huntlab-smallrna hlsmallrna -o /home/user/smallrna/hlsmallrna_output /home/user/smallrna/config.yml\n</code></pre>"},{"location":"installation/#installing-using-mamba-or-conda","title":"Installing using Mamba or Conda","text":"<p>If you can't use the containers, using mamba or conda to set up dependencies is the next supported route. Mamba is preferred. If you do not have these installed see the following links:</p> <ul> <li>Mamba: https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html</li> <li>Conda: https://docs.conda.io/projects/conda/en/stable/user-guide/install/index.html</li> </ul> <p>Then download the latest version of HuntLab-smallRNA from https://github.com/Vicky-Hunt-Lab/HuntLab-smallRNA/releases. Extract the zipped file, then navigate into the directory. To install run one of the following commands:</p> <pre><code>$ mamba env create -f environment.yml\n</code></pre> <pre><code>$ conda env create -f environment.yml\n</code></pre> <p>This will create an environment called huntlab-smallrna with the pipeline and dependencies installed into it. To test activate it with one of these commands:</p> <pre><code>$ mamba activate huntlab-smallrna\n</code></pre> <pre><code>$ conda activate huntlab-smallrna\n</code></pre> <p>Note you will have to run the above command each time you start your computer, before you use this software. Then you should be able to display the help message with the command:</p> <pre><code>$ hlsmallrna --help\n</code></pre>"},{"location":"installation/#manual-installation","title":"Manual Installation","text":"<p>If none of the above are possible, you can retrieve each dependency and manually install it. See the following list of dependencies to install:</p> <ul> <li>Python 3 - https://www.python.org/</li> <li>Pyyaml - https://pyyaml.org/</li> <li>Pysam - https://pysam.readthedocs.io/en/latest/api.html</li> <li>Biopython - https://biopython.org/</li> <li>Gffutils - https://daler.github.io/gffutils/</li> <li>Scipy - https://scipy.org/ </li> <li>Matplotlib - https://matplotlib.org/</li> <li>Cutadapt - https://cutadapt.readthedocs.io/en/stable/</li> <li>Unitas - https://www.smallrnagroup.uni-mainz.de/software.html</li> <li>Bowtie2 - https://bowtie-bio.sourceforge.net/bowtie2/index.shtml</li> <li>Samtools - http://www.htslib.org/</li> <li>Bedtools - https://bedtools.readthedocs.io/en/latest/</li> <li>Eggnog-mapper - https://github.com/eggnogdb/eggnog-mapper</li> <li>R -https://www.r-project.org/</li> <li>topGO - https://bioconductor.org/packages/3.22/bioc/html/topGO.html</li> <li>pip - https://packaging.python.org/en/latest/tutorials/installing-packages/</li> </ul> <p>Once all of these are installed you need to download and extract the latest version of HuntLab-smallRNA from https://github.com/Vicky-Hunt-Lab/HuntLab-smallRNA/releases. Navigate into the extracted directory and run the following command to install:</p> <pre><code>$ pip install .\n</code></pre> <p>Then you should be able to display the help message with the command:</p> <pre><code>$ hlsmallrna --help\n</code></pre>"},{"location":"other-tasks/","title":"Other Tasks","text":"<p>This page covers some other bioinformatics tasks you may want to combine with the pipeline, using both programs included with and separate from the pipeline.</p>"},{"location":"other-tasks/#plotting-genome-location","title":"Plotting Genome Location","text":""},{"location":"other-tasks/#basic-plot","title":"Basic Plot","text":"<p>A common task you might want to do is plotting the location of things within the genome, for example, genome features you are interested in or the positions of small RNAs you have aligned to the genome. To make this easy, a script is included in this environment called <code>build_coord_files</code>. This automatically generates tsv files for use with the R package <code>chromPlot</code>. This section explains how you can generate a plot with it.</p> <p>Firstly, you need at least two files: a full genome in a FASTA or FASTQ file and a set of locations you are interested in, either as an alignment output (in SAM or BAM format) or as feature annotations in GFF format. To start produce the genome coordinate file with the command: (assuming <code>genome.fasta</code> is your genome file)</p> <pre><code>$ build_coord_files -o genome_coord.tsv genome.fasta \n</code></pre> <p>By default, the script will figure out what type of output to produce by the file extension. But if it can\u2019t, the user will need to provide a flag to tell it what type of input you are using (in this case <code>--fasta</code>). Next we produce the coordinates file for the item of interest, assuming it is in <code>alignment.sam</code> you can run:</p> <pre><code>$ build_coord_files -o alignment_coord.tsv alignment.sam\n</code></pre> <p>This will produce two files, one for coordinates on the sense strand and one for coordinates on the antisense strand. Finally, we can use these files to plot the result. If it isn\u2019t already, install chromPlot with bioconducter using the following R command:</p> <pre><code>&gt; BiocManager::install(\"chromPlot\")\n</code></pre> <p>Then you should be able to create a plot using the following R code (of two example chromosomes called \"SRAE_chr1\" and \"SRAE_chr2\"):</p> <pre><code>chrom_coords &lt;- read.csv(\"/path/to/genome_coord.tsv\", sep = \"\\t\")\nsense_pos &lt;- read.csv(\"/path/to/sense_alignment_coord.tsv\", sep = \"\\t\")\nantisense_pos &lt;- read.csv(\"/path/to/antisense_alignment_coord.tsv\", sep = \"\\t\")\n\nlibrary(chromPlot)\n\nchromPlot(\n  gaps = chrom_coords, annot1 = sense_pos, annot2 = antisense_pos, plotRndchr = T,\n  chr = c(\"SRAE_chr1\", \"SRAE_chr2\"), bin = 50000, \n  chrSide = c(-1, 1, -1, -1, 1, -1, -1, 1)\n)\n</code></pre> <p>The script breaks down as follows:</p> <ul> <li>First three lines load in the data we just produced with <code>build_coord_files</code></li> <li>Following line loads the chromPlot library into R</li> <li>The final line plots the data with chromPlot:</li> <li><code>gaps</code> defines what each chromosome should look like</li> <li><code>annot1</code> and <code>annot2</code> define the annotation data to show</li> <li><code>plotRndchr</code> disables the assumption in chromPlot that the chromosomes are labelled with numbers</li> <li><code>chr</code> selects which chromosomes to plot by specifying an array of names</li> <li><code>bin</code> sets the bin size to group the features into when plotting</li> <li><code>chrSide</code> defines which side of the chromosome to plot each feature, the only change we have made from the default is setting the second item to <code>1</code> as opposed to <code>-1</code>. This ensures <code>annot2</code> is plotted on the opposite side to <code>annot1</code></li> </ul> <p>The resulting plot will look something like this:</p> <p></p>"},{"location":"other-tasks/#dealing-with-multiple-scaffolds","title":"Dealing with Multiple Scaffolds","text":"<p>In more complex cases, one or more of your chromosomes may be split into multiple scaffolds. <code>build_coord_files</code> has a scaffold aware mode that can automatically try to merge these, but it will only work if your scaffold\u2019s IDs are in the form of <code>&lt;chromosome_name&gt;_scaffold&lt;scaffold_number&gt;</code> e.g. <code>SRAE_chrX_scaffold1</code>. Once you have this, you can generate the data files with the <code>-c</code> flag set, as follows:</p> <pre><code>$ build_coord_files -c -o genome_coord.tsv genome.fasta \n$ build_coord_files -c --genome-coords genome_coord.tsv -o alignment_coord.tsv alignment.sam\n</code></pre> <p>Note you need to provide the genome coords file when generating files for what you are plotting, this allows for a correction of coordinates to be made from where scaffolds are merged. In addition to the regular files, this produces <code>scaffold_info_genome_coord.tsv</code>, that can be used to add scaffold dividers to your plots. To do this, the following R script can be run:</p> <pre><code>chrom_coords &lt;- read.csv(\"/path/to/genome_coord.tsv\", sep = \"\\t\")\nsense_pos &lt;- read.csv(\"/path/to/sense_alignment_coord.tsv\", sep = \"\\t\")\nantisense_pos &lt;- read.csv(\"/path/to/antisense_alignment_coord.tsv\", sep = \"\\t\")\nscaffolds &lt;- read.csv(\"/path/to/scaffold_info_genome_coord.tsv\", sep = \"\\t\")\n\nlibrary(chromPlot)\n\nchromPlot(\n  gaps = chrom_coords, annot1 = sense_pos, annot2 = antisense_pos, plotRndchr = T,\n  chr = c(\"SRAE_chr1\", \"SRAE_chr2\"), bin = 50000, bands = scaffolds,\n  chrSide = c(-1, 1, -1, -1, 1, -1, -1, 1)\n)\n</code></pre> <p>Compared to the last script, this adds:</p> <ul> <li>The fourth line, that loads in the scaffold data</li> <li>The bands argument, that draws red lines at the end of each scaffold</li> </ul> <p>Note that, by default the bands are 20,000 bp wide, as that looks good on the plot. At that size they may not appear if you make the bins too much bigger. Therefore, if you plan to make the bins bigger, pass a larger value to the <code>--band-width</code> flag when creating the genome file. That makes the bands bigger, which results in a more visible line on the plot.</p> <p>A plot produced by this method will look something like:</p> <p> </p>"},{"location":"other-tasks/#signature-identification","title":"Signature Identification","text":"<p>TODO</p>"},{"location":"other-tasks/#atgc-richness","title":"AT/GC Richness","text":"<p>Nucleotide richness and the presence of any conserved motifs is identified using WebLogo. Sequences need to be the same length and can be either uploaded using a fasta file or can be pasted in.</p>"},{"location":"other-tasks/#upstream-motif-eg-pirna","title":"Upstream motif (e.g. piRNA)","text":"<ol> <li>Map to genome with bowtie2, convert sam to bam with <code>samtools</code>, convert bamToBed with <code>bedtools</code> </li> </ol> <pre><code>$ bowtie2 -x genome.fasta -f -U sequences.fasta -S sequences_mapped.sam\n$ samtools view sequences_mapped.sam -o sequences_mapped.bam\n$ bamToBed -i sequences.bam &gt; sequences.bed\n</code></pre> <ol> <li>Extract flanking sequences with flankBed in <code>bedtools</code> (need to use bedtools format genome file - generate with faidx and cut):</li> </ol> <pre><code>$ samtools faidx genome.fasta  \n$ cut -f 1,2 genome.fa.fai &gt; chrom.sizes\n$ flankBed -i sequences.bed -g chrom.sizes -b 100 &gt; sequences_100nt_flank.bed\n</code></pre> <p>or for 60 upstream only:</p> <pre><code>$ flankBed -i sequences.bed -g chrom.sizes -l 60 -r 0 &gt; sequnences_60nt.bed\n</code></pre> <ol> <li>Extract fasta sequences from bed fastFromBed with bedtools.</li> </ol> <pre><code>$ fastaFromBed -fi genome.fasta -bed sequences_100nt_Flank.bed -fo sequences_100nt_Flank_seqs.fasta\n</code></pre>"},{"location":"other-tasks/#ping-pong-signature","title":"Ping Pong signature","text":"<p>To find ping-pong signature, Unitas with the option -pp can be used to find 5\u2019 overlaps of mapped sequence reads to the genome and calculate a Z-score for the enrichment of 10 bp overlaps. <code>map.file</code> should be in SAM or ELAND3 format.</p> <pre><code>$ perl unitas.pl -pp -input map.file  \u2013species x \u2013refseq reference.fasta\n</code></pre>"},{"location":"other-tasks/#dicer-signature-steprna","title":"Dicer Signature (StepRNA)","text":"<p>To install stepRNA, see the documentation on the GitHub page.</p> <p>stepRNA is able to identify a Dicer processing signature from a small RNA sequence dataset. It requires two FASTA files as input that have had their adapters already trimmed from the ends.</p> <pre><code>$ stepRNA --reference REFERENCE.fa --reads READS.fa\n</code></pre> <ul> <li>READS.fa should contain all of the small RNA sequencing reads.</li> <li>REFERENCE.fa is usually filtered to investigate small RNAs of interest e.g. 26G sRNAs.</li> </ul> <p>Identical reads in the READ and REFERENCE files can also be removed before searching for a Dicer signature, if desired, by using <code>-e/--remove_exact</code>. </p> <p>Importantly the FASTA headers must be unique - this can be done by stepRNA with <code>-u/--make_unique</code>.</p> <p>stepRNA will then generate: </p> <ul> <li>BAM alignment files (with different combinations of overhang lengths)</li> <li>Overhang length CSV</li> <li>Passenger Read Length CSV</li> </ul> <p>These can then be used to plot the distribution and/or further explore the reads that have aligned. </p> <p>Note: If the sRNA lengths in the read file are all the same i.e. 21 nt long, stepRNA will not be able to find overhangs due to the scoring system. In this case the <code>-m/--min_score</code> should be set to an appropriate value; we recommend sRNA length - 7nt (e.g. 21 - 6 = 15).</p> <p>Use <code>stepRNA --help</code> to bring up the command line help, a description of the methods can be found in the stepRNA publication.</p> <pre><code>stepRNA [-h] -r REFERENCE -q READS [-n NAME] [-d DIRECTORY]\n               [-m MIN_SCORE] [-e] [-u] [-j] [-V]\n\nAlign a reference RNA file to read sequences. Output will be a set of CSV files containing information about the length of the reads, number of reads aligned to a reference sequence and the length of overhangs of the alignment.\nReference RNA file will be automatically indexed\n\nOptional Arguments:\n  -h, --help            show this help message and exit\n  -n NAME, --name NAME  Prefix for the output files\n  -d DIRECTORY, --directory DIRECTORY\n                        Directory to store the output files\n  -m MIN_SCORE, --min_score MIN_SCORE\n                        Minimum score to accept, default is the shortest read\n                        length\n\nRequired Arguments:\n  -r REFERENCE, --reference REFERENCE\n                        Path to the reference sequences\n  -q READS, --reads READS\n                        Path to the read sequences\n\nFlags:\n  -e, --remove_exact    Remove exact read matches to the reference sequence\n  -u, --make_unique     Make FASTA headers unique in reference and reads i.e.\n                        &gt;Read_1 &gt;Read_2\n  -j, --write_json      Write count dictionaries to a JSON file\n  -V, --version         Print version number then exit.\n</code></pre>"},{"location":"other-tasks/#same-strand-overlap","title":"Same Strand Overlap","text":"<p>If you wish to detect same strand overlaps, you can use the <code>overlap_ss</code> script that is installed in the same environment as this pipeline. This uses a number of bash programs to create files that show where two sets of small RNA that appear on the same strand overlap.</p> <p>To use this script you need two sets of small RNA as FASTA or FASTQ files, one for the base and one for the overlap, plus the genome of the species of interest. You can then run the script in the following way:</p> <pre><code>$ overlap_ss genome.fasta smallRNA1.fastq smallRNA2.fastq\n</code></pre> <p>This script will then create output in the output directory specified in <code>config.toml</code> under the directory <code>samestrand_overlap/</code>.</p>"},{"location":"other-tasks/#mirna","title":"miRNA","text":"<p>TODO</p>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>References of how to use the command line interface of the program and notes on some ways particular commands work that could trip you up.</p> <p>General help message is as follows:</p> <pre><code>usage: hlsmallrna [-h] [-o OUTPUT] [-t THREADS] [-k] [-v] config_file\n\nPipeline to process small RNAs - version 2\n\npositional arguments:\n  config_file           Path to YAML config file\n\noptions:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        Directory to write output to (will be created if it\n                        doesn't exist, default: hlsmallrna_output)\n  -t THREADS, --threads THREADS\n                        Number of threads to run the pipeline on (default: 4)\n  -k, --keep-files      If set, keep the intermediate files, to help debug the\n                        application\n  -v, --verbose         If set, print the output for the intermediate commands\n</code></pre> <p>The Config File</p> <p>If you are looking for instructions on writing the config file, use the relevent page of the walkthrough to help.</p>"},{"location":"cli-reference/build-coord-files/","title":"Build Coord Files","text":"<pre><code>usage: build_coord_files [-h] [-a] [-q] [-s] [-b] [-g] [-r] [-c]\n                        [--feature FEATURE] [--genome-coords GENOME_COORDS]\n                        [--band-width BAND_WIDTH] [-o OUTPUT]\n                        input_file\n\nConvert common bioinformatics file formats into coordinate file to plot\n\npositional arguments:\n  input_file            File to convert, attempts to autodetect type\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a, --fasta           Treat input as a FASTA file\n  -q, --fastq           Treat input as a FASTQ file\n  -s, --sam             Treat input as a SAM file\n  -b, --bam             Treat input as a BAM file\n  -g, --gff             Treat input as a GFF file\n  -r, --rm-fa-out       Treat input as a RepeatMasker .fa.out file\n  -c, --scaffold-aware  Merge scaffolds into one chromosome\n  --feature FEATURE     Select a gff feature to use\n  --genome-coords GENOME_COORDS\n                        File containing the coordinates of the genome\n  --band-width BAND_WIDTH\n                        Size of the bands showing change in scaffolds\n  -o OUTPUT, --output OUTPUT\n                        File to output to\n</code></pre>"},{"location":"cli-reference/extractnc/","title":"ExtractNC","text":"<pre><code>usage: extract_nc [-h] [-o OUTPUT] genome gff_file\n\npositional arguments:\n  genome                FASTA containing the genome to extract from\n  gff_file              GFF file containing annotations of CDS and mRNA\n                        regions\n\noptions:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        FASTA file to write output to\n</code></pre> <p>Input files:</p> <ul> <li> <p><code>genome</code> - file containing the whole genome of the species of interest</p> </li> <li> <p><code>gff_file</code> - GFF3 file containing annotations at least for the mRNA and coding region (labelled CDS) for the genome</p> </li> </ul> <p>Output files:</p> <ul> <li><code>noncoding.fasta</code> - FASTA file containing only the transcribed noncoding regions of the DNA</li> </ul> <p>Warning</p> <p>The method used here will not work if there a coding region is labelled outside a single mRNA region. The program does a check before running to make sure this is true and throws an exception before trying to run if so, to prevent nonsense results from being produced.</p>"},{"location":"cli-reference/label-for-unitas/","title":"Label for Unitas","text":"<pre><code>usage: label_for_unitas [-h] [-o OUTPUT] label file_path\n\nProgram to automatically prepend unitas labels to all the sequences in a FASTA\nfile\n\npositional arguments:\n  label                 Label to prepend to the sequences in a fasta file\n  file_path             Path to the fasta file to label\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        File to output to, defaults to labelled.fasta\n</code></pre>"},{"location":"cli-reference/overlapss/","title":"Overlap SS","text":"<pre><code>usage: overlap_ss [-h] [-q] genome rna_file_1 rna_file_2\n\nLooks for overlaps of two classes of RNA on the same strand of DNA\n\npositional arguments:\n  genome    FASTA file containing the genome of the organism\n  rna_file_1   File containing the RNA to use as a base\n  rna_file_2   File containing the RNA to look for overlaps with\n\noptional arguments:\n  -h, --help   show this help message and exit\n  -q, --quiet  Suppress output from intermediate commands\n</code></pre>"},{"location":"walkthrough/","title":"Walkthrough","text":"<p>This walkthrough covers all of the major tasks of the pipeline and how they can be performed, either together or separately and considerations for your analysis. To start, here is an overview of the analysis the pipeline can perform:</p>"},{"location":"walkthrough/#trim","title":"Trim","text":"<p>This filters low quality ends, trims 5' adapters and then trims 3' adapters. Any reads without a detectable 3' adapter are removed, as they may not cover a full small RNA.</p>"},{"location":"walkthrough/#sort","title":"Sort","text":"<p>Firstly, aligns the small RNA to the genome and removes any that don\u2019t align to remove contamination. Then sorts into FASTQ files of each length within a specified range. Finally, plots a graph of frequency of each length and first base of small RNA to give an overview of your sample.</p>"},{"location":"walkthrough/#unitas","title":"Unitas","text":"<p>This step takes the files of each small RNA length from sort and runs unitas on them to classify the origins of the small RNA. Then plots a graph of the origins of each length of small RNA.</p>"},{"location":"walkthrough/#targetid","title":"TargetID","text":"<p>This aligns the reverse complement of the small RNA exactly to FASTAs of interesting targets (e.g. genes in the organism). These confident targets can then optionally be enriched for GO terms, KEGG pathways and Pfams using eggnog-mapper to allocate.</p> <p>Pipeline Stage Ordering</p> <p>While you do not have to run all of these parts of the pipeline, they will always run in the order:</p> <p>Trim -&gt; Sort -&gt; Unitas -&gt; TargetID -&gt; Enrich </p> <p>If you want to do a different order you will need to write multiple config files and run the pipeline multiple times.</p>"},{"location":"walkthrough/config/","title":"The Config File","text":"<p>HuntLab-smallRNA 2 uses an overhauled config system that is different to HuntLab-smallRNA 1. This is based on a YAML file and the idea that anything that affects the analysis should be in the config file, while anything that doesn't is a command line argument. Alongside this it has been made easier to run multiple stages in one command. An annotated version of a minimal config file to run all 4 parts of the analysis is as follows:</p> <pre><code># The small RNA FASTQ file to use as input to the pipeline\nsmallRNA_fastq: smallrna.fastq\n\n# The trim section, as it is present trim will be run\ntrim:\n  # Use the bulit-in adapaters for the Qiagen kit\n  kit: qiagen\n\n# The sort section, as it is present sort will be run\nsort:\n  # The genome to align to filter small RNA \n  genome: genome.fasta\n\n# The unitas section, as it is present unitas will be run\nunitas:\n  # files to pass to unitas refseq and the labels to give them\n  refseq:\n    - miRNA: test/miRNA.fasta\n    - piRNA: test/piRNA.fasta\n    - tRNA: test/tRNA.fasta\n    - TE: test/transposable_elements.fasta\n\n# The targetid section, as it is present targetid will be run\ntargetid:\n  # Files containing the interesting targets to align to\n  target_files:\n    - test/file1.fasta\n    - test/file2.fasta\n</code></pre> <p>Absolute and Reletive Paths</p> <p>When parsing the config file, the small RNA pipeline assumes that all paths in the config file are reletive to the directory the config file is in. So if you move the config file, things will break. If you need to move the config file, use absolute paths (that start with <code>/</code>) instead.</p> <p>To run this, you could save the file as <code>hlsmallrna_config.yml</code> and run:</p> <pre><code>$ hlsmallrna hlsmallrna_config.yml\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif hlsmallrna hlsmallrna_config.yml\n</code></pre></p> <p>The results would then appear in the directory <code>hlsmallrna_output/</code>, presuming all the sequence data referenced is real. A more comprehensive file to do a similar analysis to the first one is:</p> <pre><code># The small RNA FASTQ file to use as input to the pipeline\nsmallRNA_fastq: smallrna.fastq\n# CDS FASTA of the species of interest, can be used in sort, unitas and targetid\ncds: cds.fasta\n# unspliced transcriptome FASTA of the species of interest, can be used in unitas and targetid\nunspliced_transcriptome: unspliced.fasta\n\n\n# The trim section, as it is present trim will be run\ntrim:\n  # The 5\u2019 adapter sequence to trim\n  5_prime: ACGTTTAG\n  # The 3\u2019 adapter sequence to trim\n  3_prime: CGTAGGAT\n  # The quality filter cutoff to use\n  min_quality: 20\n\n# The sort section, as it is present sort will be run\nsort:\n  # The genome to align to filter small RNA \n  genome: genome.fasta\n  # If True, also align to the CDS file above\n  align_to_cds: True\n  # Minimum length of small RNA sequence to keep\n  min_length: 15\n  # Maximum length of small RNA sequence to keep\n  max_length: 50\n  # Max number to allow when aligning to the genome and CDS\n  mismatches: 0\n\n# The unitas section, as it is present unitas will be run\nunitas:\n  # files to pass to unitas refseq and the labels to give them\n  refseq:\n    # add genes to unitas, special keyword to add using cds and unspliced_transcriptome specified earlier\n    - gene\n    - miRNA: test/miRNA.fasta\n    - piRNA: test/piRNA.fasta\n    - tRNA: test/tRNA.fasta\n    - TE: test/transposable_elements.fasta\n  # species name to pass to unitas\n  species: x\n\n# The targetid section, as it is present targetid will be run\ntargetid:\n  # Minimum length of small RNA, higher number will speed up runtime, used to calculate bowtie2 seed length\n  min_seq_length: 5\n  # Number of mismatches to allow when aligning to the targets\n  mismatches: 0\n  # Files containing the interesting targets to align to\n  target_files:\n    - test/file1.fasta\n    - test/file2.fasta\n  # If present also enrich GO terms, KEGG pathways and Pfams of targets\n  enrich:\n    # Path to the eggnog-mapper data dir\n    eggnog_data_dir: /home/user/eggnog-mapper-data\n    # Target files to ignore during enrichment\n    exclude_files:\n      - test/file2.fasta\n</code></pre> <p>If you want to skip a step, just leave it out of the file. e.g. if you only want to run sort and unitas, you could use the file:</p> <pre><code>smallRNA_fastq: smallrna.fastq\nsort:\n  genome: genome.fasta\nunitas:\n  refseq:\n    - miRNA: test/miRNA.fasta\n    - piRNA: test/piRNA.fasta\n    - tRNA: test/tRNA.fasta\n    - TE: test/transposable_elements.fasta\n</code></pre> <p>Command Line Arguments</p> <p>While most things are now specified in the config file, there are still a few CLI arguments that are as follows:</p> <p><code>-o</code>, <code>--ouput</code> - directory to write pipeline output to (default: hlsmallrna_output)</p> <p><code>-t</code>, <code>--threads</code> - number of threads to use when running analysis tools (default: 4)</p> <p><code>-k</code>, <code>--keep-files</code> - If set, don't delete intermediate files, useful for debugging or if you need an intermediate file later</p> <p><code>-v</code>, <code>--verbose</code> - makes the pipeline print out the output of the intermediate commands</p> <p>The following sections will explain each parameter in the config file in detail.</p>"},{"location":"walkthrough/prereq/","title":"Prerequisites and Considerations","text":"<p>Before we get on to how to run the pipeline this page covers what files are needed to run the pipeline and things to think about to inform the parameters to set. Read each section you want to run carefully.</p>"},{"location":"walkthrough/prereq/#trim","title":"Trim","text":"<p>The trimming in the pipeline is what we think is best practice for the small RNA data we use - remove low quality ends and trim any 5' adapters first, then trim the 3' adapter and remove any sequences that lack it - as they are likely incomplete or noise. If you want to do something different, you can do this and provide the already trimmed small RNAs to the pipeline to run the other analysis. To run this, you will need the following data:</p> <ul> <li>Small RNA-seq reads in FASTQ or FASTA format</li> <li>3' adapter sequence from small RNA library prep</li> <li>Optionally, a 5' adapter sequence and quality cutoff to use</li> </ul> <p>Small RNA Library Prep Kits</p> <p>For the Quiagen and NEB kits the best adapters to use are built into the pipeline. You just need to know the kit and if we have data in the forward or reverse direction. </p> <p>Paired End Sequencing</p> <p>Most small RNA-seq provides a single sequence, but if you have paired end data, you should only provide the read that contains the sequence of the small RNA to the program (Usually the forward read), not it's reverse complement.</p>"},{"location":"walkthrough/prereq/#sort","title":"Sort","text":"<p>This takes trimmed reads and aligns them to the genome and optionally a set of CDS sequences to catch small RNA derived from spliced genes. Then sorts them into length and plots length and first base to give you an overview of the small RNAs you have. It also outputs a summary table on the number and percentage of small RNA reads aligned and FASTQs of small RNAs of each class (length and first base) for easier downstream analysis. For this you'll need:</p> <ul> <li>A FASTQ or FASTA of trimmed small RNA sequences (can be automatically retrieved if trim is run)</li> <li>A genome assembly to align the reads to</li> <li>Optionally, a set of CDS sequences to also align reads to </li> <li>Optionally, A minimum and maximum length of small RNA to consider, otherwise defaults to 18 - 30 nt</li> <li>Optionally, A number of mismatches to use when aligning, otherwise defaults to 0</li> </ul> <p>Mismatches</p> <p>By default, sort allows no mismatches or gaps, which is fine if you have a good reference genome that is of a close relative to the sample small RNA-seq was performed on and want to be conservative about what you retain. If you know your genome is likely to have lots of SNPs from the reference or are uncertain about how good you assembly is, you may want to up the amount of mismatches allowed to compensate for this.</p> <p>Downstream use of BLAST</p> <p>While it seems like a good to run small RNAs through BLAST downstream, if you do this you need to be careful of the parameters used, particularly word size and E value. This is because BLAST will not return any hits if your sequence is shorter than the word size set (often above 20nt) and the short size of small RNA may mean even close to exact marches have a high E value. Due to this a basic search may return no hits, even if huntlab-smallrna has found an exact match in your genome.</p>"},{"location":"walkthrough/prereq/#unitas","title":"Unitas","text":"<p>Unitas runs unitas on a number of files representing small RNA lengths and plots a graphs of the origin or class for each small RNA length. This requires the following files:</p> <ul> <li>A directory of small RNAs of different lengths named in the form length.fastq - where X is the length of the small RNA. This can be automatically derived if sort has been run</li> <li>One or both of:<ul> <li>A species name in the form supported by unitas - see examples in https://www.smallrnagroup.uni-mainz.de/software/unitas_documentation_1.7.0.pdf </li> <li>One or more files containing known sequences of a particular class (e.g. miRNA, rRNA, tRNA, Transposable Elements etc.)</li> </ul> </li> <li>Optionally a CDS and/or unspliced transcriptome files to supplement the above</li> </ul> <p>Labelling for Unitas</p> <p>Unitas expects files that have the class of each sequence labelled in their ID e.g. for TEs with ids te1 and te2, the file would look like: <pre><code>&gt;TE|te1\nACGT...\n&gt;TE|te2\nCGAT...\n</code></pre> Unless you have mixed files, the pipeline can label this for you, so don't worry about adding that yet. See the unitas section for information on this.</p>"},{"location":"walkthrough/prereq/#targetid","title":"TargetID","text":"<p>This stage aligns the reverse complement exactly to lists of potential targets, to find likely targets of a small RNA, outputting both and overall list and by class (e.g. 22Us). Then it can optionally enrich the targets GO terms, KEGG pathways and Pfams to help understand the tragets. For this you will need:</p> <ul> <li>FASTQ file of small RNAs or a directory or sorted small RNAs - can be derived from trim or sort if run</li> <li>One or more FASTA files containing sequences of potential targets (e.g. genes, TEs, host genes etc.)</li> <li>Optionally, the number of mismatches to tolerate when aligning, if not 0</li> <li>If you want to run the enrichment, an eggnog-mapper data directiory (see targetid section on how to create this)</li> <li>Optionally, a list of target files to exclude from the enrichment</li> </ul> <p>Now you know what you need you can continue to the next page of the tutorial to understand the config file you need to write.</p>"},{"location":"walkthrough/sort/","title":"Running Sort","text":""},{"location":"walkthrough/sort/#basic-configuration","title":"Basic Configuration","text":"<p>At minimum, sort requires a set of trimmed reads and a genome to align to from the species the small RNAs came from. If trim is in the same config file, the set to trimmed reads will be taken from the output of trim. Examples are as follows.</p> <p>Without running trim. <pre><code>smallRNA_fastq: smallrna_trimmed.fastq\nsort:\n  genome: genome.fasta\n</code></pre></p> <p>With running trim. <pre><code>smallRNA_fastq: smallrna_untrimmed.fastq\ntrim:\n  ...\nsort:\n  genome: genome.fasta\n</code></pre></p> <p>Once this config is written, it can be run as usual using:</p> <pre><code>$ hlsmallrna config.yml\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif hlsmallrna config.yml\n</code></pre></p>"},{"location":"walkthrough/sort/#optional-parameters","title":"Optional Parameters","text":""},{"location":"walkthrough/sort/#align_to_cds","title":"align_to_cds","text":"<p>If true aligns reads that don't align to the genome to the specified CDS file, keeping any that align. This allows for small RNA that are fragments of genes and align accross introns to be kept as they may not align to the genome. </p> <pre><code>cds: cds_sequences.fasta\n...\nsort:\n  ...\n  align_to_cds: True\n</code></pre>"},{"location":"walkthrough/sort/#min_length","title":"min_length","text":"<p>Sets a minimum sequence length to look at (default is 18 nt). Anything shorter is filtered during sorting. e.g. to filter anything below 10 nt set the following:</p> <pre><code>sort:\n  min_length: 10\n</code></pre>"},{"location":"walkthrough/sort/#max_length","title":"max_length","text":"<p>Sets a maximum sequence length to look at (default is 30 nt). Anything longer is filtered during sorting. e.g. to filter anything above 50 nt set the following:</p> <pre><code>sort:\n  max_length: 50\n</code></pre>"},{"location":"walkthrough/sort/#mismatches","title":"mismatches","text":"<p>Number of mismatches to allow in bowtie2 when aligning to the genome and CDS, defaults to 0. See the Considerations page for information about why you'd want to change this. The example below sets this to allow 1 mismatch:</p> <pre><code>sort:\n  mismatches: 1\n</code></pre> <p>Warning</p> <p>The small RNA pipeline supresses gaps by makeing them equal to 100 mismatches. If you set this over 100, some gaps may be included in the alignment.</p>"},{"location":"walkthrough/sort/#output-files","title":"Output Files","text":""},{"location":"walkthrough/sort/#alignment_reporttsv","title":"alignment_report.tsv","text":"<p>This is a table showing an overview of how many small RNA reads successfully aligned to the genome and optionally the CDS. It contains the following metrics:</p> <ul> <li>Total Reads</li> <li>Total Mapped</li> <li>Percentage Mapped</li> <li>Total Unmapped</li> <li>Percentage Unmapped</li> <li>Mapped to Genome</li> <li>Percentage Mapped to Genome</li> <li>Unmapped to Genome</li> <li>Percentage Unmapped to Genome</li> <li>Mapped to CDS</li> <li>Percentage Mapped to CDS (but not to genome)</li> <li>Unmapped to CDS or genome</li> <li>Percentage Unmapped to CDS or genome</li> </ul>"},{"location":"walkthrough/sort/#countstab","title":"counts.tab","text":"<p>Read counts is TSV format for each small RNA sequence, designed as input to a differential expression analysis, if that wanted.</p>"},{"location":"walkthrough/sort/#rna_length_reportcsv","title":"rna_length_report.csv","text":"<p>Table of counts of small RNA for each length and first base, in a easily human readable format.</p>"},{"location":"walkthrough/sort/#baseplotpng","title":"baseplot.png","text":"<p>Plot of frequency of length and first base in the dataset.</p>"},{"location":"walkthrough/sort/#baseplot_datacsv","title":"baseplot_data.csv","text":"<p>That length and first base data used in baseplot.png - normalised to percentages. Should be used if the user wants to replot that graph or feed into downstream analysis.</p>"},{"location":"walkthrough/sort/#binned_length_rna","title":"binned_length_rna","text":"<p>Directory containing FASTQ files for each RNA length - named lengthX.fastq where X is the length of small RNA in the file.</p>"},{"location":"walkthrough/sort/#binned_group_rna","title":"binned_group_rna","text":"<p>Directory containing FASTQ files for each RNA group - defined by length and first base - named {length}{first_base}.fastq (e.g. 22G.fastq) where {length} is the length of small RNA in the file and {first_base} is the letter corresponding to the first base.</p>"},{"location":"walkthrough/targetid/","title":"Running TargetID","text":""},{"location":"walkthrough/targetid/#basic-configuration","title":"Basic Configuration","text":"<p>To run TargetID, you need two things:</p> <ol> <li> <p>A small RNA file - if sort is specified the output of that is used - if not <code>smallRNA_fastq</code> is used.</p> </li> <li> <p>One or more files containing potential targets of small RNAs (e.g. genes, transposons, lncRNA etc.) specified in the <code>targetid</code> section as <code>target_files</code>.</p> </li> </ol> <p>For example:</p> <pre><code>smallRNA_fastq: small_rna.fastq\ntargetid:\n  target_files:\n    - targets/lncRNA.fasta\n    - targets/genes.fasta\n</code></pre> <p>Once this config is written, it can be run as usual using:</p> <pre><code>$ hlsmallrna config.yml\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif hlsmallrna config.yml\n</code></pre></p>"},{"location":"walkthrough/targetid/#optional-parameters","title":"Optional Parameters","text":""},{"location":"walkthrough/targetid/#min_seq_length","title":"min_seq_length","text":"<p>This is used to set the seed length in bowtie2 when aligning to targets (defaults to 5). Larger numbers makes it fasta but less accurate for sequences close to this length. For example, to set to 18 add the following:</p> <pre><code>targetid:\n  min_seq_length: 18\n</code></pre>"},{"location":"walkthrough/targetid/#mismatches","title":"mismatches","text":"<p>Number of mismatches to allow in bowtie2 when aligning to the target files, defaults to 0. See the Considerations page for information about why you'd want to change this. The example below sets this to allow 1 mismatch:</p> <pre><code>targetid:\n  mismatches: 1\n</code></pre>"},{"location":"walkthrough/targetid/#enrich-eggnog_data_dir","title":"enrich - eggnog_data_dir","text":"<p>The pipeline can optionally enrich GO terms, KEGG pathways and PFams for the targets of the small RNA. This is a rough analysis based on <code>emapper.py --itype CDS</code> mode that uses <code>diamond blastx</code> to map, so is likely only a rough analysis. May be useful if you want to have a quick look at if there are any common annotations within the targets though should be redone probably later. To run this you need to add the eggnog_data_dir to the config file. This directory can be created with the command:</p> <pre><code>$ mkdir -p /home/user/path/to/eggnog-data\n$ download_eggnog_data.py -y --data_dir /home/user/path/to/eggnog-data\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ mkdir -p /home/user/path/to/eggnog-data\n$ apptainer run -B $HOME:$HOME hlsmallrna.sif download_eggnog_data.py -y --data_dir /home/user/path/to/eggnog-data\n</code></pre></p> <p>Then add the following to the config file</p> <pre><code>targetid:\n  ...\n  enrich:\n    eggnog_data_dir: /home/user/path/to/eggnog-data\n</code></pre>"},{"location":"walkthrough/targetid/#enrich-exclude","title":"enrich - exclude","text":"<p>If you have run targetid with targets it doesn't make sense to map to the eggnog database (e.g. lncRNA), you can exclude them with the exclude key, but must ensure the path exactly matches the one in the target_files list. e.g.</p> <pre><code>targetid:\n  target_files:\n    - targets/genes.fasta\n    - targets/lncRNA.fasta\n  enrich:\n    eggnog_data_dir: /home/user/path/to/eggnog-data\n    exclude:\n      - targets/lncRNA.fasta\n</code></pre>"},{"location":"walkthrough/targetid/#output-files","title":"Output Files","text":""},{"location":"walkthrough/targetid/#rna_target_listtsv","title":"rna_target_list.tsv","text":"<p>List of small RNA and there targets identified from the files specified.</p>"},{"location":"walkthrough/targetid/#targets_by_group","title":"targets_by_group","text":"<p>Same information as <code>rna_target_list.tsv</code>, but split by small RNA group (length and first base).</p>"},{"location":"walkthrough/targetid/#output-files-enrich","title":"Output Files - Enrich","text":"<p>These files are only produced if the <code>enrich</code> key is present.</p>"},{"location":"walkthrough/targetid/#eggnog_mapper","title":"eggnog_mapper","text":"<p>Results of the eggnog-mapper run on the target files.</p>"},{"location":"walkthrough/targetid/#targets_enriched_go_termstsv","title":"targets_enriched_go_terms.tsv","text":"<p>Enriched GO terms in the targets of small RNA vs the rest of the target files.</p>"},{"location":"walkthrough/targetid/#targets_enriched_kegg_pathwaystsv","title":"targets_enriched_kegg_pathways.tsv","text":"<p>Enriched KEGG pathways in the targets of small RNA vs the rest of the target files.</p>"},{"location":"walkthrough/targetid/#targets_enriched_pfamstsv","title":"targets_enriched_pfams.tsv","text":"<p>Enriched PFams in the targets of small RNA vs the rest of the target files.</p>"},{"location":"walkthrough/trim/","title":"Running Trim","text":""},{"location":"walkthrough/trim/#basic-configuration","title":"Basic Configuration","text":"<p>Trim requires a file of untrimmed small RNAs and the adpaters to trim - either explicitly or through the kit used - to be specified. Examples of config files for  possible usage is as follows.</p> <p>Trimming adapters with the 5' sequence ACGTTTAGAT and the 3' sequence GCTAGGATA:</p> <pre><code>smallRNA_fastq: smallrna_untrimmed.fastq\ntrim:\n  5_prime: ACGTTTAGAT\n  3_prime: GCTAGGATA\n</code></pre> <p>Trimming adapters from the qiagen kit in forward direction:</p> <pre><code>smallRNA_fastq: smallrna_untrimmed.fastq\ntrim:\n  kit: qiagen\n</code></pre> <p>Trimming adapters from the qiagen kit in reverse direction:</p> <pre><code>smallRNA_fastq: smallrna_untrimmed.fastq\ntrim:\n  kit: qiagen-rev\n</code></pre> <p>Currently the valid values for kit are:</p> <ul> <li><code>qiagen</code> - qiagen kit, forward direction</li> <li><code>qiagen-rev</code> - qiagen kit, reverse direction</li> <li><code>neb</code> - NEB kit, forward direction </li> <li><code>neb-rev</code> - NEB kit, reverse direction</li> </ul> <p>Once this config is written, it can be run as usual using:</p> <pre><code>$ hlsmallrna config.yml\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif hlsmallrna config.yml\n</code></pre></p>"},{"location":"walkthrough/trim/#optional-parameters","title":"Optional Parameters","text":""},{"location":"walkthrough/trim/#min_quality","title":"min_quality","text":"<p>This sets the quality cutoff in cutadapt when filtering low quality ends. Defaults to 20 - example below sets it to 15:</p> <pre><code>trim:\n  ...\n  min_quality: 15\n</code></pre>"},{"location":"walkthrough/trim/#output-files","title":"Output Files","text":""},{"location":"walkthrough/trim/#trimmed_readsfq","title":"trimmed_reads.fq","text":"<p>This is a FASTQ file containing all the trimmed reads that passed the filters of quaility and had a 3' adapter present.</p>"},{"location":"walkthrough/unitas/","title":"Running Unitas","text":""},{"location":"walkthrough/unitas/#basic-configuration","title":"Basic Configuration","text":"<p>Unitas requires two parameters to work - a directory containing length sorted small RNA FASTQ and a set of refseq FASTA files to use a reference for the different types of small RNA or features that they may come from.</p> <p>The former (directory containing length sorted small RNA FASTQ) can be specified in two different ways - 1. Directly though the <code>size_sorted_fastqs</code> parameter e.g.</p> <pre><code>size_sorted_fastqs: sorted_small_rna\nunitas:\n  ...\n</code></pre> <ol> <li>Through having both <code>smallRNA_fastq</code> and <code>sort</code> specified, in which case it uses the output of <code>sort</code>. e.g.</li> </ol> <pre><code>smallRNA_fastq: trimmed_smallrna.fastq\nsort:\n  ...\nunitas:\n  ...\n</code></pre> <p>The latter (set of refseq FASTA files) are specified as a list and can be written in three different forms:</p> <ol> <li>If the FASTA file is not already labelled for unitas in the IDs (i.e. ID values do not start with <code>[class_name]|</code>) the class name for the pipeline to add can be specified as a key and the file as a value. For example to add a file of miRNA called <code>microRNA.fasta</code> that should be labelled <code>miRNA</code> specify the following:</li> </ol> <pre><code>unitas:\n  refseq:\n    - miRNA: microRNA.fasta\n</code></pre> <ol> <li>If the file already has unitas labels in the IDs (i.e. ID values start with <code>[class_name]|</code>) you only need to specify the path to the FASTA file. e.g. if you have a labeled set of tRNA in a file called <code>transferRNA.fasta</code> specify the following:</li> </ol> <pre><code>unitas:\n  refseq:\n    - transferRNA.fasta\n</code></pre> <ol> <li>If you want to add gene features from <code>cds</code> and/or <code>unspliced_transcriptome</code> specify the special string <code>gene</code>. e.g.</li> </ol> <pre><code>cds: cds.fasta\nunspliced_transcriptome: unspliced.fasta\nunitas:\n  refseq:\n    - gene\n</code></pre> <p>These can be mixed and matched, so a full example could be:</p> <pre><code>smallRNA_fastq: trimmed_smallrna.fastq\nsort:\n  ...\nunitas:\n  refseq:\n    - gene\n    - transferRNA.fasta\n    - miRNA: microRNA.fasta\n</code></pre> <p>Once this config is written, it can be run as usual using:</p> <pre><code>$ hlsmallrna config.yml\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif hlsmallrna config.yml\n</code></pre></p>"},{"location":"walkthrough/unitas/#optional-parameters","title":"Optional Parameters","text":""},{"location":"walkthrough/unitas/#species","title":"species","text":"<p>If unitas allows, you can set a species to have unitas download existing data on it's small RNAs from the internet to help with classification. For example:</p> <pre><code>unitas:\n  species: caenorabditis_elegans\n</code></pre>"},{"location":"walkthrough/unitas/#utility-programs","title":"Utility Programs","text":"<p>Two utility programs to help with creating input for unitas are contained in the small RNA pipeline.</p>"},{"location":"walkthrough/unitas/#label_for_unitas","title":"label_for_unitas","text":"<p>This is a simple program that adds a class label that unitas can read to a FASTA file of sequences. It is recommened to not use this directly most of the time and instead use the key-value labelling syntax shown above. However, if you need a unitas labelled file, you can run the following:</p> <pre><code>$ label_for_unitas [class] [FASTA_file]\n</code></pre> <p>e.g. to label <code>transposons.fasta</code> with TE and write the result to <code>transposons_labelled.fasta</code>, you could run:</p> <pre><code>$ label_for_unitas TE transposons.fasta -o transposons_labelled.fasta\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif label_for_unitas TE transposons.fasta -o transposons_labelled.fasta\n</code></pre></p>"},{"location":"walkthrough/unitas/#extract_nc","title":"extract_nc","text":"<p>If you want to test what small RNA come form noncoding reigons - outside of genes - specifically you can use this tool to extract those from the genome. It also adds the unitas label noncoding to the ID of the sequences for you. </p> <p>Warning</p> <p>Most of the time you do not want to do this on the first run - as Unitas will likely double classify anything that aligns to something like a transposon. It is advised to take anything unitas has not classified on the first run and only run that on the noncoding if you want the information.</p> <p>It can be run as follows:</p> <pre><code>$ extract_nc [genome_FASTA] [annotation_GFF] -o [output_FASTA]\n</code></pre> <p>Tip</p> <p>Remember if you install via apptainer or docker you will need to prepend the command from the install page. For apptainer this command becomes: <pre><code>$ apptainer run -B $HOME:$HOME hlsmallrna.sif extract_nc [genome_FASTA] [annotation_GFF] -o [output_FASTA]\n</code></pre></p>"},{"location":"walkthrough/unitas/#output-files","title":"Output Files","text":""},{"location":"walkthrough/unitas/#unitas","title":"unitas","text":"<p>Directory containing the raw output of unitas for each length file run. Can be inspected to extract details for particular small RNAs.</p>"},{"location":"walkthrough/unitas/#unitas_summarycsv","title":"unitas_summary.csv","text":"<p>Human-readable unitas classification summary by length. Conatins the classifications for each RNA length on a row, allowing for inspection of all the details at once.</p>"},{"location":"walkthrough/unitas/#unitasgraphpng","title":"unitasGraph.png","text":"<p>Graph of unitas classification by length - uses only top level unitas classes.</p>"},{"location":"walkthrough/unitas/#unitas_graph_datacsv","title":"unitas_graph_data.csv","text":"<p>Data for <code>unitasGraph.png</code>, in case it needs to be replotted, misses the more granular classes from <code>unitas_summary.csv</code>.</p>"}]}