{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Hunt Lab Small RNA Pipeline Documentation","text":"<p>This tool is designed to automate a lot of the common bioinformatics performed on small RNA by the Hunt Lab. It is deliberately designed to be highly configurable so it can be easily applied to a wide range of scenarios, though most of our work is on nematode and nematomorph worms.</p> <p>Use the tabs above or buttons below to navigate this site.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can obtain the code for the pipeline from https://github.com/Vicky-Hunt-Lab/HuntLab-smallRNA. To download, click the code button and copy the URL. You can then download it to a computer with git installed on it by opening the command line and running:</p> <pre><code>$ git clone https://github.com/Vicky-Hunt-Lab/HuntLab-smallRNA.git\n</code></pre> <p>It is recommended to use mamba to install this pipeline. To perform the installation, ensure mamba is installed on the machine, navigate to the directory containing the code and environment.yml file, then run:</p> <pre><code>$ mamba env create -f environment.yml\n</code></pre> <p>This will create a conda environment called <code>huntlab-smallrna</code>. This can then be activated each time you want to use the software with the command:</p> <pre><code>$ mamba activate huntlab-smallrna\n</code></pre> <p>By default, this provides the <code>hlsmallrna</code> executable. This provides all of the tasks listed in this documentation, each one can be run by typing <code>hlsmallrna</code> followed by the name and options for the task.</p>"},{"location":"other-tasks/","title":"Other Tasks","text":"<p>This page covers some other bioinformatics tasks you may want to combine with the pipeline, using both programs included with and separate from the pipeline.</p>"},{"location":"other-tasks/#plotting-genome-location","title":"Plotting Genome Location","text":""},{"location":"other-tasks/#basic-plot","title":"Basic Plot","text":"<p>A common task you might want to do is plotting the location of things within the genome, for example, genome features you are interested in or the positions of small RNAs you have aligned to the genome. To make this easy, a script is included in this environment called <code>build_coord_files</code>. This automatically generates tsv files for use with the R package <code>chromPlot</code>. This section explains how you can generate a plot with it.</p> <p>Firstly, you need at least two files: a full genome in a FASTA or FASTQ file and a set of locations you are interested in, either as an alignment output (in SAM or BAM format) or as feature annotations in GFF format. To start produce the genome coordinate file with the command: (assuming <code>genome.fasta</code> is your genome file)</p> <pre><code>$ build_coord_files -o genome_coord.tsv genome.fasta \n</code></pre> <p>By default, the script will figure out what type of output to produce by the file extension. But if it can\u2019t, the user will need to provide a flag to tell it what type of input you are using (in this case <code>--fasta</code>). Next we produce the coordinates file for the item of interest, assuming it is in <code>alignment.sam</code> you can run:</p> <pre><code>$ build_coord_files -o alignment_coord.tsv alignment.sam\n</code></pre> <p>This will produce two files, one for coordinates on the sense strand and one for coordinates on the antisense strand. Finally, we can use these files to plot the result. If it isn\u2019t already, install chromPlot with bioconducter using the following R command:</p> <pre><code>&gt; BiocManager::install(\"chromPlot\")\n</code></pre> <p>Then you should be able to create a plot using the following R code (of two example chromosomes called \"SRAE_chr1\" and \"SRAE_chr2\"):</p> <pre><code>chrom_coords &lt;- read.csv(\"/path/to/genome_coord.tsv\", sep = \"\\t\")\nsense_pos &lt;- read.csv(\"/path/to/sense_alignment_coord.tsv\", sep = \"\\t\")\nantisense_pos &lt;- read.csv(\"/path/to/antisense_alignment_coord.tsv\", sep = \"\\t\")\n\nlibrary(chromPlot)\n\nchromPlot(\n  gaps = chrom_coords, annot1 = sense_pos, annot2 = antisense_pos, plotRndchr = T,\n  chr = c(\"SRAE_chr1\", \"SRAE_chr2\"), bin = 50000, \n  chrSide = c(-1, 1, -1, -1, 1, -1, -1, 1)\n)\n</code></pre> <p>The script breaks down as follows:</p> <ul> <li>First three lines load in the data we just produced with <code>build_coord_files</code></li> <li>Following line loads the chromPlot library into R</li> <li>The final line plots the data with chromPlot:</li> <li><code>gaps</code> defines what each chromosome should look like</li> <li><code>annot1</code> and <code>annot2</code> define the annotation data to show</li> <li><code>plotRndchr</code> disables the assumption in chromPlot that the chromosomes are labelled with numbers</li> <li><code>chr</code> selects which chromosomes to plot by specifying an array of names</li> <li><code>bin</code> sets the bin size to group the features into when plotting</li> <li><code>chrSide</code> defines which side of the chromosome to plot each feature, the only change we have made from the default is setting the second item to <code>1</code> as opposed to <code>-1</code>. This ensures <code>annot2</code> is plotted on the opposite side to <code>annot1</code></li> </ul> <p>The resulting plot will look something like this:</p> <p></p>"},{"location":"other-tasks/#dealing-with-multiple-scaffolds","title":"Dealing with Multiple Scaffolds","text":"<p>In more complex cases, one or more of your chromosomes may be split into multiple scaffolds. <code>build_coord_files</code> has a scaffold aware mode that can automatically try to merge these, but it will only work if your scaffold\u2019s IDs are in the form of <code>&lt;chromosome_name&gt;_scaffold&lt;scaffold_number&gt;</code> e.g. <code>SRAE_chrX_scaffold1</code>. Once you have this, you can generate the data files with the <code>-c</code> flag set, as follows:</p> <pre><code>$ build_coord_files -c -o genome_coord.tsv genome.fasta \n$ build_coord_files -c --genome-coords genome_coord.tsv -o alignment_coord.tsv alignment.sam\n</code></pre> <p>Note you need to provide the genome coords file when generating files for what you are plotting, this allows for a correction of coordinates to be made from where scaffolds are merged. In addition to the regular files, this produces <code>scaffold_info_genome_coord.tsv</code>, that can be used to add scaffold dividers to your plots. To do this, the following R script can be run:</p> <pre><code>chrom_coords &lt;- read.csv(\"/path/to/genome_coord.tsv\", sep = \"\\t\")\nsense_pos &lt;- read.csv(\"/path/to/sense_alignment_coord.tsv\", sep = \"\\t\")\nantisense_pos &lt;- read.csv(\"/path/to/antisense_alignment_coord.tsv\", sep = \"\\t\")\nscaffolds &lt;- read.csv(\"/path/to/scaffold_info_genome_coord.tsv\", sep = \"\\t\")\n\nlibrary(chromPlot)\n\nchromPlot(\n  gaps = chrom_coords, annot1 = sense_pos, annot2 = antisense_pos, plotRndchr = T,\n  chr = c(\"SRAE_chr1\", \"SRAE_chr2\"), bin = 50000, bands = scaffolds,\n  chrSide = c(-1, 1, -1, -1, 1, -1, -1, 1)\n)\n</code></pre> <p>Compared to the last script, this adds:</p> <ul> <li>The fourth line, that loads in the scaffold data</li> <li>The bands argument, that draws red lines at the end of each scaffold</li> </ul> <p>Note that, by default the bands are 20,000 bp wide, as that looks good on the plot. At that size they may not appear if you make the bins too much bigger. Therefore, if you plan to make the bins bigger, pass a larger value to the <code>--band-width</code> flag when creating the genome file. That makes the bands bigger, which results in a more visible line on the plot.</p> <p>A plot produced by this method will look something like:</p> <p> </p>"},{"location":"other-tasks/#signature-identification","title":"Signature Identification","text":"<p>TODO</p>"},{"location":"other-tasks/#atgc-richness","title":"AT/GC Richness","text":"<p>Nucleotide richness and the presence of any conserved motifs is identified using WebLogo. Sequences need to be the same length and can be either uploaded using a fasta file or can be pasted in.</p>"},{"location":"other-tasks/#upstream-motif-eg-pirna","title":"Upstream motif (e.g. piRNA)","text":"<ol> <li>Map to genome with bowtie2, convert sam to bam with <code>samtools</code>, convert bamToBed with <code>bedtools</code> </li> </ol> <pre><code>$ bowtie2 -x genome.fasta -f -U sequences.fasta -S sequences_mapped.sam\n$ samtools view sequences_mapped.sam -o sequences_mapped.bam\n$ bamToBed -i sequences.bam &gt; sequences.bed\n</code></pre> <ol> <li>Extract flanking sequences with flankBed in <code>bedtools</code> (need to use bedtools format genome file - generate with faidx and cut):</li> </ol> <pre><code>$ samtools faidx genome.fasta  \n$ cut -f 1,2 genome.fa.fai &gt; chrom.sizes\n$ flankBed -i sequences.bed -g chrom.sizes -b 100 &gt; sequences_100nt_flank.bed\n</code></pre> <p>or for 60 upstream only:</p> <pre><code>$ flankBed -i sequences.bed -g chrom.sizes -l 60 -r 0 &gt; sequnences_60nt.bed\n</code></pre> <ol> <li>Extract fasta sequences from bed fastFromBed with bedtools.</li> </ol> <pre><code>$ fastaFromBed -fi genome.fasta -bed sequences_100nt_Flank.bed -fo sequences_100nt_Flank_seqs.fasta\n</code></pre>"},{"location":"other-tasks/#ping-pong-signature","title":"Ping Pong signature","text":"<p>To find ping-pong signature, Unitas with the option -pp can be used to find 5\u2019 overlaps of mapped sequence reads to the genome and calculate a Z-score for the enrichment of 10 bp overlaps. <code>map.file</code> should be in SAM or ELAND3 format.</p> <pre><code>$ perl unitas.pl -pp -input map.file  \u2013species x \u2013refseq reference.fasta\n</code></pre>"},{"location":"other-tasks/#dicer-signature-steprna","title":"Dicer Signature (StepRNA)","text":"<p>To install stepRNA, see the documentation on the GitHub page.</p> <p>stepRNA is able to identify a Dicer processing signature from a small RNA sequence dataset. It requires two FASTA files as input that have had their adapters already trimmed from the ends.</p> <pre><code>$ stepRNA --reference REFERENCE.fa --reads READS.fa\n</code></pre> <ul> <li>READS.fa should contain all of the small RNA sequencing reads.</li> <li>REFERENCE.fa is usually filtered to investigate small RNAs of interest e.g. 26G sRNAs.</li> </ul> <p>Identical reads in the READ and REFERENCE files can also be removed before searching for a Dicer signature, if desired, by using <code>-e/--remove_exact</code>. </p> <p>Importantly the FASTA headers must be unique - this can be done by stepRNA with <code>-u/--make_unique</code>.</p> <p>stepRNA will then generate: </p> <ul> <li>BAM alignment files (with different combinations of overhang lengths)</li> <li>Overhang length CSV</li> <li>Passenger Read Length CSV</li> </ul> <p>These can then be used to plot the distribution and/or further explore the reads that have aligned. </p> <p>Note: If the sRNA lengths in the read file are all the same i.e. 21 nt long, stepRNA will not be able to find overhangs due to the scoring system. In this case the <code>-m/--min_score</code> should be set to an appropriate value; we recommend sRNA length - 7nt (e.g. 21 - 6 = 15).</p> <p>Use <code>stepRNA --help</code> to bring up the command line help, a description of the methods can be found in the stepRNA publication.</p> <pre><code>stepRNA [-h] -r REFERENCE -q READS [-n NAME] [-d DIRECTORY]\n               [-m MIN_SCORE] [-e] [-u] [-j] [-V]\n\nAlign a reference RNA file to read sequences. Output will be a set of CSV files containing information about the length of the reads, number of reads aligned to a reference sequence and the length of overhangs of the alignment.\nReference RNA file will be automatically indexed\n\nOptional Arguments:\n  -h, --help            show this help message and exit\n  -n NAME, --name NAME  Prefix for the output files\n  -d DIRECTORY, --directory DIRECTORY\n                        Directory to store the output files\n  -m MIN_SCORE, --min_score MIN_SCORE\n                        Minimum score to accept, default is the shortest read\n                        length\n\nRequired Arguments:\n  -r REFERENCE, --reference REFERENCE\n                        Path to the reference sequences\n  -q READS, --reads READS\n                        Path to the read sequences\n\nFlags:\n  -e, --remove_exact    Remove exact read matches to the reference sequence\n  -u, --make_unique     Make FASTA headers unique in reference and reads i.e.\n                        &gt;Read_1 &gt;Read_2\n  -j, --write_json      Write count dictionaries to a JSON file\n  -V, --version         Print version number then exit.\n</code></pre>"},{"location":"other-tasks/#same-strand-overlap","title":"Same Strand Overlap","text":"<p>If you wish to detect same strand overlaps, you can use the <code>overlap_ss</code> script that is installed in the same environment as this pipeline. This uses a number of bash programs to create files that show where two sets of small RNA that appear on the same strand overlap.</p> <p>To use this script you need two sets of small RNA as FASTA or FASTQ files, one for the base and one for the overlap, plus the genome of the species of interest. You can then run the script in the following way:</p> <pre><code>$ overlap_ss genome.fasta smallRNA1.fastq smallRNA2.fastq\n</code></pre> <p>This script will then create output in the output directory specified in <code>config.toml</code> under the directory <code>samestrand_overlap/</code>.</p>"},{"location":"other-tasks/#mirna","title":"miRNA","text":"<p>TODO</p>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>References of how to use the command line interface of the program and notes on some ways particular commands work that could trip you up.</p> <p>General help message is as follows:</p> <pre><code>usage: hlsmallrna [-h] [-q] [-C PATH_TO_CONFIG]\n                {process,sort,extractnc,unitas,targetid,all} ...\n\nPipeline to process small RNAs\n\npositional arguments:\n  {process,sort,extractnc,unitas,targetid,all}\n    process             Preprocessing for the RNA\n    sort                Find RNAs that align to a genome and sort them by\n                        length\n    extractnc           Extract the noncoding region from a fasta with a GFF\n                        file\n    unitas              Run unitas on split files and merge results\n    targetid            Align small RNA to a number of genome features to find\n                        out what is targeted\n    all                 Run process, sort and unitas one after the other\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -q, --quiet           Suppress output from intermediate commands\n  -C PATH_TO_CONFIG, --path-to-config PATH_TO_CONFIG\n                        Path to the TOML format config file to use\n</code></pre>"},{"location":"cli-reference/build-coord-files/","title":"Build Coord Files","text":"<pre><code>usage: build_coord_files [-h] [-a] [-q] [-s] [-b] [-g] [-r] [-c]\n                        [--feature FEATURE] [--genome-coords GENOME_COORDS]\n                        [--band-width BAND_WIDTH] [-o OUTPUT]\n                        input_file\n\nConvert common bioinformatics file formats into coordinate file to plot\n\npositional arguments:\n  input_file            File to convert, attempts to autodetect type\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a, --fasta           Treat input as a FASTA file\n  -q, --fastq           Treat input as a FASTQ file\n  -s, --sam             Treat input as a SAM file\n  -b, --bam             Treat input as a BAM file\n  -g, --gff             Treat input as a GFF file\n  -r, --rm-fa-out       Treat input as a RepeatMasker .fa.out file\n  -c, --scaffold-aware  Merge scaffolds into one chromosome\n  --feature FEATURE     Select a gff feature to use\n  --genome-coords GENOME_COORDS\n                        File containing the coordinates of the genome\n  --band-width BAND_WIDTH\n                        Size of the bands showing change in scaffolds\n  -o OUTPUT, --output OUTPUT\n                        File to output to\n</code></pre>"},{"location":"cli-reference/extractnc/","title":"ExtractNC","text":"<pre><code>extarctnc [-h] genome gff_file\n\npositional arguments:\n  genome    FASTA containing the genome to extract from\n  gff_file  GFF file containing annotations of CDS and mRNA regions\n\noptional arguments:\n  -h, --help  show this help message and exit\n</code></pre> <p>Input files:</p> <ul> <li> <p><code>genome</code> - file containing the whole genome of the species of interest</p> </li> <li> <p><code>gff_file</code> - GFF3 file containing annotations at least for the mRNA and coding region (labelled CDS) for the genome</p> </li> </ul> <p>Output files:</p> <ul> <li><code>noncoding.fasta</code> - FASTA file containing only the transcribed noncoding regions of the DNA</li> </ul> <p>Note the method used here will not work if there a coding region is labelled outside a single mRNA region. The program does a check before running to make sure this is true and throws an exception before trying to run if so, to prevent nonsense results from being produced.</p>"},{"location":"cli-reference/label-for-unitas/","title":"Label for Unitas","text":"<pre><code>usage: label_for_unitas [-h] [-o OUTPUT] label file_path\n\nProgram to automatically prepend unitas labels to all the sequences in a FASTA\nfile\n\npositional arguments:\n  label                 Label to prepend to the sequences in a fasta file\n  file_path             Path to the fasta file to label\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o OUTPUT, --output OUTPUT\n                        File to output to, defaults to labelled.fasta\n</code></pre>"},{"location":"cli-reference/overlapss/","title":"Overlap SS","text":"<pre><code>usage: overlap_ss [-h] [-q] genome rna_file_1 rna_file_2\n\nLooks for overlaps of two classes of RNA on the same strand of DNA\n\npositional arguments:\n  genome    FASTA file containing the genome of the organism\n  rna_file_1   File containing the RNA to use as a base\n  rna_file_2   File containing the RNA to look for overlaps with\n\noptional arguments:\n  -h, --help   show this help message and exit\n  -q, --quiet  Suppress output from intermediate commands\n</code></pre>"},{"location":"cli-reference/process/","title":"Process","text":"<pre><code>process [-h] [-a ADAPTER] [-g FRONT] [-b ANYWHERE]\n                        [-c CUTOFF]\n                        small_rna\n\npositional arguments:\n  small_rna             Path to FASTQ containing the small RNA\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a ADAPTER, --adapter ADAPTER\n                        Sequence of the adapter to remove from the 3' end\n  -g FRONT, --front FRONT\n                        Sequence of the adapter to remove from the 5' end\n  -b ANYWHERE, --anywhere ANYWHERE\n                        Sequence of the adapters to remove from both ends\n  -c CUTOFF, --cutoff CUTOFF\n                        Quality cutoff to trim RNA sequences at\n</code></pre> <p>Input files:</p> <ul> <li><code>small_rna</code> - fastq file containing raw RNA-seq data</li> </ul> <p>Output files:</p> <ul> <li> <p><code>Fastqc/</code> - directory containing the raw output of FastQC</p> </li> <li> <p><code>Trimmed_rna.fastq</code> - file containing the raw RNA with adapters removed (only produced if an adapter sequence is provided)</p> </li> <li> <p><code>Cut_sequences.fastq</code> - sequences with low quality parts removed</p> </li> </ul> <p>Note that the parts of this step can easily be skipped. If you want to skip adapter trimming, don\u2019t specify any adapters with <code>-a</code>, <code>-g</code> or <code>-c</code>. If you don\u2019t want to run fastQC set <code>-c 0</code>. The program knows that in these cases, the steps do not have to be run.</p>"},{"location":"cli-reference/sort/","title":"Sort","text":"<pre><code>sort [-h] [-d CDS] [-l MIN_LENGTH] [-x MAX_LENGTH]\n                    [-m REF_MISMATCHES] [--disable-alignment]\n                    small_rna [genome]\n\npositional arguments:\n  small_rna             Path to FASTQ containing the small RNA\n  genome                Genome to align against\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d CDS, --cds CDS     Optional CDS region, also align this to the CDS region\n                        as well as the genome\n  -l MIN_LENGTH, --min-length MIN_LENGTH\n                        Minimum length to bin\n  -x MAX_LENGTH, --max-length MAX_LENGTH\n                        Maximum length to bin\n  -m REF_MISMATCHES, --ref-mismatches REF_MISMATCHES\n                        Number of mismatches to use in bowtie2, None for\n                        default behaviour\n  --disable-alignment   Skip the alignment to the reference genome step\n</code></pre> <p>Input files:</p> <ul> <li> <p><code>small_rna</code> - fastq file containing RNA with adapters removed</p> </li> <li> <p><code>genome</code> - Reference genome of the species you are using to align against in fasta format</p> </li> </ul> <p>Output files:</p> <ul> <li> <p><code>Bbmap_index/</code> - contains the index of the reference genome created by bowtie2</p> </li> <li> <p><code>Mapped_sequences.fastq</code> - sequences successfully mapped to the reference by bowtie2</p> </li> <li> <p><code>binned_rna/</code> - directory containing one fastq file for each length of sequence contained in the bowtie2 output</p> </li> <li> <p><code>rna_length_report.csv</code> - table showing a summary of the RNAs by length and first base</p> </li> <li> <p><code>Baseplot.png</code> - plot of the length and first base of the RNAs, using the data in rna_length_report.csv</p> </li> <li> <p><code>baseplot_data.csv</code> - raw data used to make baseplot.png to allow for easy regraphing</p> </li> </ul> <p>Note BBMap has been replaced with bowtie2 for this step, but file names haven't been changed.</p>"},{"location":"cli-reference/targetid/","title":"TargetID","text":"<pre><code>targetid [-h] [-m MIN_SEQ_LENGTH] [-t TARGET_FILES [TARGET_FILES ...]]\n                        [--num-mismatches NUM_MISMATCHES]\n                        small_rna\n\npositional arguments:\n  small_rna             Path to the FASTQ containing the small RNA to find targets of\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -m MIN_SEQ_LENGTH, --min-seq-length MIN_SEQ_LENGTH\n                        Minimum sequence length to properly align\n  -t TARGET_FILES [TARGET_FILES ...], --target-files TARGET_FILES [TARGET_FILES ...]\n                        Files containing genome features that could be targeted\n  --num-mismatches NUM_MISMATCHES\n                        Number of mismatches to allow in the alignment, defaults to 0\n</code></pre> <p>Input: </p> <ul> <li> <p><code>small_rna</code> - fastq file containing small RNA to look for targets of</p> </li> <li> <p><code>target_files</code> - one or more fastq files containing a list of potential target sequences</p> </li> </ul> <p>Output:</p> <ul> <li> <p><code>bowtie_indexes/</code> - indexes produced of the target files with bowtie2</p> </li> <li> <p><code>target_alignments/</code> - SAM files containing the results of alignment attempts and FASTQ files containing all the small RNA successfully aligned against the targets. One set of files are produced for each target file provided</p> </li> <li> <p><code>rna_target_list.csv</code> - list of RNA target pairs</p> </li> </ul> <p>Note that the samtools view command used in this step is the only one that has defaults pre-set in the <code>samtools_view_params</code> config key, namly <code>-h -F 256 -F 4</code>. They will be removed if you set the value differently in the config file. To only add parameters, you will need to set these ones again before the extra ones you want to set. E.g. <code>samtools_view_params = [\"-h\", \"-F\", \"256\", \"-F\", \"4\", ...]</code></p> <p>Make sure all of your target files are labelled with what they are, by prepending the name and | (the bar or pipe character) to the ID in the fasta file. If you don\u2019t do this, it will not be nicely sorted in the results correctly.</p>"},{"location":"cli-reference/unitas/","title":"Unitas","text":"<pre><code>unitas [-h] [-d CDS] [-u UNSPLICED_TRANSCRIPTOME]\n                        [-r [REFSEQ [REFSEQ ...]]] [-s SPECIES]\n                        path_to_rnas\n\npositional arguments:\n  path_to_rnas          Path to the folder with varying length RNAs in\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d CDS, --cds CDS     Optional CDS region, passed to unitas\n  -u UNSPLICED_TRANSCRIPTOME, --unspliced-transcriptome UNSPLICED_TRANSCRIPTOME\n                        Optional, unspliced transcriptome, passed to unitas\n  -r [REFSEQ [REFSEQ ...]], --refseq [REFSEQ [REFSEQ ...]]\n                        References for use with unitas\n  -s SPECIES, --species SPECIES\n                        Species to set in unitas arguments\n</code></pre> <p>Input files:</p> <ul> <li><code>path_to_rnas</code> - path to the directory containing fastq files of each set of  small RNAs you want to procesus in unitas</li> </ul> <p>Note: to get unitas to work, you need to set either the species to a compatible species or provide one or more files of reference small RNAs. These can either be done with the -s and -r optional arguments or by adding them to your configuration file (see below).</p> <ul> <li> <p><code>CDS</code> - Coding sequence, pipeline automatically labels with Gene and combines with the unspliced transcriptome, optional</p> </li> <li> <p><code>unspliced_transcriptome</code> - Unspliced transcriptome, pipeline automatically labels with <code>Gene</code> and combines with the <code>CDS</code>, optional</p> </li> </ul> <p>Output files:</p> <ul> <li> <p><code>unitas/</code> - directory containing the results for all the unitas runs performed by the program</p> </li> <li> <p><code>unitas_summery.csv</code> - CSV file containing the combined summaries of all of the unitas runs (plus some extra numbers). It is recommended to open it in a spreadsheet package (e.g. microsoft excel, libreoffice calc) as there is a lot of data and it may look a mess in a text editor.</p> </li> <li> <p><code>UnitasGraph.png</code> - graph showing the categories allocated by unitas against the length of the small RNA</p> </li> <li> <p><code>unitas_graph_data.csv</code> - raw data used for creating unitasGraph.png to allow for easy regraphing</p> </li> </ul>"},{"location":"walkthrough/config-and-troubleshooting/","title":"Configuration and Troubleshooting Notes","text":""},{"location":"walkthrough/config-and-troubleshooting/#configuration-file","title":"Configuration File","text":"<p>For ease of use this program requires a configuration file in TOML format to run successfully. At minimum it can be a blank file, but it is strongly recommended setting at least the <code>output_directory</code> setting to be named something more useful than <code>output</code>, the default setting.</p> <p>By default the program tries to use config.toml in your current directory, but it can be set to a different file using the <code>-C</code> option before specifying which task to run, e.g.:</p> <pre><code>$ hlsmallrna -C alternate.toml sort ...\n</code></pre> <p>The layout of a TOML file has a number of sections each with a number of configuration keys. Each key has an expected type (e.g. string, integer, floating point number etc.) and the program will check they are as expected before running. If one is wrong, the program will crash and alert the user of the problem. A list of these keys and example values can be found in the README.md included with the program.</p> <p>Manually setting parameters of internal commands For advanced uses, you may want to add parameters to the internal commands run. This can be done through variables in the cli-tools section of the configuration file. A full list of these parameters can be found in the README.md provided with the code. </p> <p>There is a main one that you can set, called <code>&lt;name&gt;_params</code>. It is a list of custom parameters to be added on to the command when called. For example if you wanted to set min-length to 10 for FastQC you could add the following to the configuration file:</p> <pre><code>[cli-tools]\n[cli-tools.fastqc]\nfastqc_params = [\"--min_length\", \"10\"]\n</code></pre>"},{"location":"walkthrough/config-and-troubleshooting/#suppressing-excess-output","title":"Suppressing excess output","text":"<p>If you do not want to view the output from each of the commands, you can pass the <code>-q</code>option to the main script. (Before the task selection, like with <code>-C</code>). It is recommended to test the command first however, as this option sometimes suppresses useful error messages.</p> <p>Note: this doesn\u2019t stop all output, only that of internal commands. If you don\u2019t want any progress messages whatsoever, only errors and warnings from python, set <code>-q</code> twice. E.g. <code>-q -q</code> or <code>-qq</code>.</p>"},{"location":"walkthrough/config-and-troubleshooting/#troubleshooting","title":"Troubleshooting","text":"<p>If it is taking too long to run or producing odd data, it is strongly recommended to delete or move the output directory somewhere else, then do a clean run. This is because some steps use the data in the output directory as input, so may be combining old and new data.</p> <p>When using the <code>targetid</code> command, <code>samtools</code> is used to filter out duplicates and create the FASTQ file outputs. <code>samtools</code> is known to be picky about how the input file is layed out, so will fail. The program should keep running, but if you want these files, check the following in  your input files:</p> <ul> <li>For FASTA files, there is no <code>@</code> at the start of any of the header strings</li> <li>There are no duplicate headers in any of the input files</li> </ul>"},{"location":"walkthrough/quick-start/","title":"Quick Start","text":"<p>To use this pipeline, you will need at least a FASTQ file containing raw small RNA-Seq reads. Then depending on what you want to achieve, you can run different steps of the pipeline. If you ever get stuck and need to see the options of a particular stage, all parts have their own help message, that can be seen by passing <code>--help</code> after the name of the stage. </p> <p>Before starting, you will need to create a configuration file that allows you to specify some parameters in advance, so you don\u2019t have to keep retyping them. By default, it looks for these in a file in your current directory called <code>config.toml</code>, alternatives can be specified by passing the name to the <code>-C</code> argument before the name of the stage to run. More details on this can be found in the Configuration file section, but for now setup a simple file to specify an output directory of <code>output/</code> by putting the following in <code>config.toml</code>:</p> <pre><code>[general]\noutput_directory = \"./output\"\n</code></pre> <p>In addition, check that all of the commands can be run by just typing their name in the command line, as this is how the program tries to use them by default. If they can\u2019t, you can set a custom path by setting the relevant <code>path_to_</code> variable in the configuration file. For example if unitas is run with <code>unitas.pl</code> instead of just <code>unitas</code> add the following to the bottom of the config file:</p> <pre><code>[cli-tools]\n[cli-tools.unitas]\npath_to_unitas = \"unitas.pl\"\n</code></pre>"},{"location":"walkthrough/quick-start/#process","title":"Process","text":"<p>The first stage is Process. This is for if you have raw data that hasn\u2019t had it\u2019s adapters trimmed and been quality filtered, so if your data has had this done to it already, this step can be skipped. To run you need a FASTQ file containing raw small RNA and the sequence and end of any adapters attached during sequencing.</p> <p>Once you have this data, to include the trimming in the run, you need to set one of three flags with the adapter sequence, depending on the position of the particular adapter. </p> <p>If your adapter is on the 3\u2019 end only, use <code>-a</code>; if it is from the  5\u2019 end only, use <code>-g</code> and if it could be on either end use <code>-b</code>. If you don\u2019t need adapters trimmed, just don\u2019t specify any of them and the step will be skipped. For example, if your small RNAs are in <code>smallRNA.fastq</code> and you want to trim the adapter sequence <code>AGCATA</code> from the 3\u2019 end only, you would run:</p> <pre><code>$ hlsmallrna process -a AGCATA smallRNA.fastq\n</code></pre> <p>In addition, this step runs FastQC to produce a report on the quality of the small RNA and automatically cuts anything with a lower quartile of quality below a cutoff. By default, this is set to 20, but can be changed by the user using the <code>-c</code> flag. If you do not want this, you can set <code>-c 0</code> and the FastQC step will be skipped for efficiency. For example if you want to change the cutoff for the last command to 5, you could run:</p> <pre><code>$ hlsmallrna process -c 5 -a AGCATA smallRNA.fastq\n</code></pre> <p>This produces a number of files in the output directory, importantly <code>cut_sequences.fastq</code> has the sequences that have adapters trimmed and low quality parts removed. (See CLI Reference section for information on other output for all of the commands).</p>"},{"location":"walkthrough/quick-start/#sort","title":"Sort","text":"<p>The second stage is Sort. This stage aligns the small RNAs to the genome of the organism and filters out any that don\u2019t align, to remove contamination. Then it splits the remaining reads into FASTQ files by length, to allow for easier classification. </p> <p>To run this, you need a FASTQ file of processed small RNA and a FASTA file containing the genome of the organism of interest. For example, if your small RNA are in <code>smallRNA.fastq</code> and your genome is in <code>genome.fasta</code> you can run:</p> <pre><code>$ hlsmallrna sort smallRNA.fastq genome.fasta\n</code></pre> <p>If you are only interested in a subset of lengths of small RNA, this step can be set to restrict the lengths it outputs with <code>-l</code> for minimum and <code>-x</code> for maximum. For example, if you only want small RNA with lengths between 12 and 30, you could run:</p> <pre><code>$ hlsmallrna sort -l 12 -x 30 smallRNA.fastq genome.fasta\n</code></pre> <p>By default this aligns the small RNA to the genome with bowtie2\u2019s default settings, which allow different amounts of mismatches depending on how long the RNA is. Details of this can be found in the score configuration options in the manual, that can be found at: https://bowtie-bio.sourceforge.net/bowtie2/manual.shtml. To deal with cases where we may want to do a more stringent run, the <code>-m</code> or <code>--ref-mismatches</code> argument can be supplied with the number of mismatches for bowtie2 to allow. For example, if you want to perform an operation using the same files as above, but only include small RNA that map exactly to the genome, you could run:</p> <pre><code>$ hlsmallrna sort -m 0 smallRNA.fastq genome.fasta\n</code></pre> <p>This command produces a few useful files in the output directory: </p> <ul> <li> <p><code>binned_rna/</code> - directory containing one fastq file for each length of small RNA</p> </li> <li> <p><code>rna_length_report.csv</code> - table showing a summary of the RNAs by length and first base</p> </li> <li> <p><code>baseplot.png</code> - plot of the length and first base of the RNAs (this is sometimes wrong, replot from the csv values for now, will fix matplotlib code soon)</p> </li> </ul>"},{"location":"walkthrough/quick-start/#unitas","title":"Unitas","text":"<p>The third stage is Unitas. This runs unitas on a directory containing a range of lengths of small RNA to classify the origin of the RNA. To do this, you will need files containing reference sets of the genome targets you wish to find, with labels in their IDs and a directory containing small RNA of different lengths, similar to the output of sort.</p> <p>You can set the reference file using the <code>-r</code> command line argument, but it is easier to set them in the configuration file, as it makes the command shorter to type. If your reference files are in the same directory you are running in and called <code>ref1.fasta</code>, <code>ref2.fasta</code> and <code>ref3.fasta</code>, you can add the following to the config file:</p> <pre><code>[command]\nrefseq = [\n    \"ref1.fasta\",\n    \"ref2.fasta\",\n    \"ref3.fasta\"\n]\n</code></pre> <p>Note that all of these reference sequences should be labelled with the name of the category they belong to and the | (bar or pipe character) before the start of their ID. If this hasn\u2019t been done and all of the sequences in a FASTA file should be labelled the same, you can use the <code>label_for_unitas</code> script that was installed with the small RNA pipeline. For example if you want to label the sequences in <code>unlabelledTEs.fasta</code> with the label TE, with the result produced in <code>teRef.fasta</code>, you could run:</p> <pre><code>$ label_for_unitas \"TE\" unlabelledTEs.fasta -o teRef.fasta\n</code></pre> <p>Once the correct reference file are set, if your small RNA, split by length, are in <code>output/binned_rna</code>, you can run:</p> <pre><code>$  hlsmallrna unitas output/binned_rna\n</code></pre> <p>This produces a useful summary and graph in the output directory:</p> <ul> <li> <p><code>unitasGraph.png</code> - graph showing the categories allocated by unitas against the length of the small RNA (this is sometimes wrong, replot from the csv values for now, will fix matplotlib code soon)</p> </li> <li> <p><code>unitas_graph_data.csv</code> - summary of the raw numbers produced from the unitas runs, used to produce the graph</p> </li> </ul> <p>If you want to get small RNA that are derived from genes, you will need to obtain both of the mRNA and CDS regions and pass them to speciled arguments in the pipeline so they can be combined. This can either be done using the config file as followers or with the corresponding command line arguments (<code>--cds</code> and <code>--unspliced-transcriptome</code>):</p> <pre><code>[command]\nrefseq = [\n    \"ref1.fasta\",\n    \"ref2.fasta\",\n    \"ref3.fasta\"\n]\ncds = \"cds_sequences.fasta\"\nunspliced_transcriptome = \"unspliced_transcriptome.fasta\"\n</code></pre>"},{"location":"walkthrough/quick-start/#extract-non-coding","title":"Extract Non-Coding","text":"<p>Sometimes you want to see if a small RNA comes from a non-coding region of the transcriptome, so the pipeline contains a utility command to automatically extract this using a genome and some annotations. At minimum, these annotations need to contain a transcribed region labelled with <code>mRNA</code> and a coding region within the transcribed region labelled <code>CDS</code>. Most of the ones on Wormbase Parasite are fine for this purpose.</p> <p>As an example, to extract the regions from <code>genome.fasta</code> using the annotations in <code>annotations.gff</code> you could run:</p> <pre><code>$ hlsmallrna extractnc genome.fasta annotations.gff\n</code></pre> <p>This will produce a FASTA file containing the non-coding regions, complete with unitas labels applied, called <code>noncoding.fasta</code> in the output directory.</p>"},{"location":"walkthrough/quick-start/#target-identification","title":"Target Identification","text":"<p>The fourth and final main step is Target Identification. This takes a set of small RNA and a set of potential targets and produces a list of genome features that are targeted by each small RNA. </p> <p>As with unitas, you can set target files using the command line option <code>-t</code> but it is easier to add them to the configuration file. For example if your target files are <code>target1.fasta</code>, <code>target2.fasta</code> and <code>target3.fasta</code>, they can be set by adding the following in the section below <code>[command]</code>:</p> <pre><code>target_files = [\n    \"target1.fasta\",\n    \"target2.fasta\",\n    \"target3.fasta\"\n]\n</code></pre> <p>Then, if your small RNA are in <code>smallRNA.fastq</code> you can run the following:</p> <pre><code>$ hlsmallrna targetid smallRNA.fastq\n</code></pre> <p>Make sure the sequences in both <code>smallRNA.fastq</code> and each of the reference files have unique sequence ids, otherwise the command will fail.</p> <p>If you are working with very short sequences (&lt;5 bases), you will need to reduce the minimum length with the -m option. Conversely, if you know your minimum length is longer than this, this step can be sped up by increasing it. For example, if you know the shortest sequence you are dealing with is 10 bases long, you could run:</p> <pre><code>$ hlsmallrna targetid -m 10 smallRNA.fastq\n</code></pre> <p>Though this is not necessary and the program will produce a correct result for sequences longer than 5 without it, so only add if you need the extra speed.</p> <p>This produces <code>rna_target_list.csv</code> which contains a list of small RNA target pairs and some general information about each pair\u2019s alignment.</p> <p>If you are dealing with a small RNA that doesn\u2019t need perfect complementarity, you can add the <code>--num-mismatches</code> option to set the number of mismatches the alignment should allow. For example, if you want to allow up to four mismatches, you could run:</p> <pre><code>$ hlsmallrna targetid --num-mismatches 4 smallRNA.fastq\n</code></pre>"},{"location":"walkthrough/quick-start/#all","title":"All","text":"<p>Since the first three steps are often run one after the other, a shorthand command <code>all</code> is provided for convenience. This takes all of the arguments from the Process, Sort and Unitas steps, then runs them, piping the result from one into the next. All files produced by those steps are then produced in the output directory. </p> <p>For example if you have small RNAs in <code>smallRNA.fastq</code>, a genome in <code>genome.fasta</code> and refseq set in the config file and you want to trim the adapter sequence <code>ACATA</code> from both ends, but not run quality filtering you could run:</p> <pre><code>$ hlsmallrna all -c 0 -b ACATA smallRNA.fastq genome.fasta\n</code></pre>"},{"location":"walkthrough/tasks/","title":"Tasks","text":"<p>Currently the following tasks have been implemented in it:</p> <ul> <li> <p>Process - Trim adapters off raw RNA-Seq data, run a quality control report and trim of any bases that fall below a specified threshold from all the RNA</p> </li> <li> <p>Sort - Align the RNA against a given reference, removing any sequences that fail to align, then split them into files based on sequence length to allow for easy further processing. Can also remove sequences below a minimum length and above a maximum length if desired</p> </li> <li> <p>ExtractNC - Using a genome and GFF file containing annotations, extract the region that is transcribed, but not a coding region</p> </li> <li> <p>Unitas - Run a directory of RNA files (e.g. output of sort step) though unitas to classify the types of RNA, then combine the summaries into one spreadsheet for easy viewing and manipulation</p> </li> <li> <p>TargetID - Identify which of a set of potential targets a set of small RNA are targeting by reverse complimenting them and aligning them to the potential targets</p> </li> </ul> <p>More in depth documentation on each of these steps is provided, starting with examples and suggestions for further processing. There is also a CLI Reference, that contains general help for each command, including what files are required and what outputs you get from each step.</p>"}]}